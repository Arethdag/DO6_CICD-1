# Basic CI/CD

Разработка простого **CI/CD** для проекта *SimpleBashUtils*. Сборка, тестирование, развертывание.


## Part 1. Настройка **gitlab-runner**

**== Задание ==**

### Поднять виртуальную машину *Ubuntu Server 22.04 LTS*

![1.0](images/1.0.PNG) 

### Скачать и установить на виртуальную машину **gitlab-runner**

> Был выбран метод установки gitlab-runner через [бинарный файл с официального сайта](https://docs.gitlab.com/runner/install/linux-manually.html)

1. Загрузить бинарный файл 
```sh
sudo curl -L --output /usr/local/bin/gitlab-runner "https://s3.dualstack.us-east-1.amazonaws.com/gitlab-runner-downloads/latest/binaries/gitlab-runner-linux-amd64"
```

![1.1](images/1.1.PNG)

2. Дать файлу разрешение на исполнение: <br>
```sh
sudo chmod +x /usr/local/bin/gitlab-runner
```

![1.2](images/1.2.PNG)

3. Создать пользователя GitLab CI <br>
```sh
sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash
```

![1.3](images/1.3.PNG)

4. Установить как службу <br>
```sh
sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner
```

![1.4](images/1.4.PNG)

5. Запустить службу
```sh
sudo gitlab-runner start
```

![1.5](images/1.5.PNG) 

### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)

> Для регистрации понадобятся URL и токен, которые можно получить на страничке задания на платформе

- Зарегистрировать gitlab-runner
```ssh
sudo gitlab-runner register
```
> Для этого необходимо ввести данные при регистрации: <br>
> 1. Cвой URL-адрес GitLab
> 2. Cвой регистрационный токен
> 3. Название раннера
> 4. Теги для заданий, разделенные запятыми
> 5. Тип исполнителя

![1.6](images/1.6.PNG) 



## Part 2. Сборка

### Напиcать этап для CI по сборке приложений из проекта *C2_SimpleBashUtils*

- В корне репозитория создать файл `.gitlab-ci.yml`

```ssh
touch .gitlab-ci.yml
```

- Добавить в файл этап запуска сборки через мейк файл из проекта C2.

> Настроим также этап, чтобы файлы, полученные после сборки (артефакты), сохранялись со сроком хранения 30 дней.

![2.1](images/2.1.PNG)

### Неподготовленная оболочка

- При пуше мы столкнемся со следующей ошибкой

![2.2](images/2.2.PNG)

> Раннер нас предупреждает, что среда не подготовлена к запуску. Причиной послужила дефолтная конфигурация gitlab-runner, производящая очистку терминала при выходе из оболочки shell. Комментирование строк данного скрипта устраняет данную ошибку

- Закомментируем строки в `/home/gitlab-runner/.bash_logout`

### Проверка сборки проекта

- Перезапустим пайплайн и проверим пропала ли ошибка

![2.3](images/2.3.PNG)

- Как можно увидеть, сборка была успешно осуществлена, исполняемые файлы были сохранены на 30 дней

![2.4](images/2.4.PNG)



## Part 3. Тест кодстайла

### Напиcать этап для CI, который запускает скрипт кодстайла (clang-format)

![3.1](images/3.1.PNG)

### Проверить зафейлился ли пайплайн, если совершена ошибка в кодстайле

- Проверим сначала вывод команды локально

![3.2](images/3.2.PNG)

- Как и ожидалось - пайплайн зафейлился

![3.3](images/3.3.PNG)

- Вывод пайплайна совпал с локальным выводом команды


### Исправить ошибку в форматировании кода и проверить результат

- Результат работы пайплайна

- Теперь проект успешно проходит тест кодстайла

![3.5](images/3.5.PNG)

## Part 4. Интеграционные тесты

### Написать этап для CI, который запускает интеграционные тесты из того же проекта

![4.1](images/4.1.PNG)

### Проверить зафейлился ли пайплайн, если обнаруживаются ошибочные рузльтаты интеграционных тестов

- Проверим сначала вывод интеграционных тестов локально

![4.2](images/4.2.PNG)

- Результат работы пайплайна

![4.5](images/4.1.PNG)

- Проект успешно проходит интеграционные тесты

![4.3](images/4.3.PNG)

![4.4](images/4.4.PNG)


## Part 5. Этап деплоя

### Поднять вторую виртуальную машину Ubuntu Server 22.04 LTS

![5.0](images/5.0.PNG)

### Статическая маршрутизация между двумя машинами

- Настроим адаптеры обоих машин на внутреннюю сеть

```sh
sudo nano /etc/netplan/00-network-manager-all.yaml
```

![5.1](images/5.1.PNG)

- Обязательно принимаем изменения в настройках адаптеров

```sh
sudo netplan apply
```

- Проверим соединение между машинами

![5.2](images/5.2.PNG)

### Генерация ssh-ключей

- Для начала сгенерируем пары ключей для каждой машины

```sh
ssh-keygen
```
![5.3](images/5.3.PNG)

- Добавим открытый ключ второй машины с вывода в ssh ключи gitlab для работы с проектом на удаленной машине

### Написать bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию /usr/local/bin второй виртуальной машины

![5.4](images/5.4.PNG)

- Проверим выполнение всех предыдущих этапов 

### Написать этап для CD, который «разворачивает» проект на другой виртуальной машине

> Данный этап будет запускаться вручную при условии, что все предыдущие этапы прошли успешно

- Теперь, когда на удаленной машине есть проект, допишем этап деплоя в `.gitlab-ci.yml`

![5.6](images/5.6.PNG)

> Этап деплоя описан таким образом, что для получения доступа к удаленному серверу применяется ssh-агент. Для его работы необходимо будет выполнить определенный ряд действий

### Настройка ssh-агента

- Следующие изменения будут происходить от суперпользователя, поэтому сразу же перейдем в этот режим на машине с развернутым раннером

```sh
sudo su
```

- Перейдем в настройки раннера и обозначим ему где искать ssh-агента. Для этого в файле конфигураций добавим строку `environment = ["SSH_AUTH_SOCK=/tmp/ssh-agent"]`

```sh
vim /etc/gitlab-runner/config.toml
```
![5.7](images/5.7.PNG)

- Далее необходимо сохранить отпечаток удаленного сервера. Для этого ключ удаленного сервера необходимо добавить в файл `known_hosts` в домашнем каталоге пользователя gitlab-runner

```sh
ssh-keyscan -H 192.10.10.2 >> /home/gitlab-runner/.ssh/known_hosts
```
![5.8](images/5.8.PNG)

- Так как раннеру необходим приватный ключ, для того, чтобы не возникало проблем с ключами доступа к директории `/home/arethdag/.ssh` и ее содержимому - скопируем закрытый ключ также в домашний каталог пользователя gitlab-runner

```sh
cp /home/arethdag/.ssh/id_rsa /home/gitlab-runner/.ssh/
```
![5.9](images/5.9.PNG)

- В домашнем каталоге раннера есть все необходимое, однако на скрине можно заметить - так как мы находимся в режиме суперпользователя, в ключах указан root. Для того, чтобы раннер сумел их счесть, поменяем пользователя на gitlab-runner

- Скопируем содержимое нашего открытого ssh-ключа на удаленный сервер

> Отвечаем `yes` на подтверждение подключения и в следующем действии вводим пароль от удаленной машины

```sh
ssh-copy-id arethdag@192.10.10.2
```
![5.10](images/5.10.PNG)

- После успешной настройки ssh-агента есть один небольшой штришок. Так как наш скрипт производит копирование в директорию, в которой у нас нет прав - даем право пользователю (в нашем случае `arethdag`) на проведение команды `mv` (по скрипту необходима команда `mv`) с правами суперпользователя без ввода пароля. Для этого на удаленной машине в файле `/etc/sudoers` допишем строку `arethdag ALL=(ALL) NOPASSWD: /bin/mv`

```sh
sudo visudo
```
![5.11.0](images/5.11.0.PNG)

![5.11](images/5.11.PNG)

- Теперь можно с уверенностью сказать, что этап деплоя не выдаст ошибок. Перезапустим службу раннера и тем самым закончим настройку ssh-агента

```sh
sudo systemctl restart gitlab-runner.service
```

![5.12](images/5.12.PNG)

### Проверка этапа деплоя

![5.13](images/5.13.PNG)



## [Part 6. Дополнительно. Уведомления](#содержание)

### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем «arethdag DO6 CI/CD» в Telegram

> Текст уведомления будет содержать информацию об успешности прохождения как этапа CI, так и этапа CD. <br>
> В остальном текст уведомления может быть произвольным.

- Найдем в телеграме через поиск `BotFather`

- Запустим бота и напишем `/newbot`

> В диалоге необходимо будет написать: <br>
> - имя бота `arethdag_bot» в Telegram` <br>
> - используем для бота (имя должно быть уникальным и заканчиваться на `bot`)

![6.1](images/6.1.PNG)

- В результате мы получили `API` бота. Теперь найдем бота `getmyid_bot` и напишем ему `/start` для получения нашего `ID`

![6.2](images/6.2.PNG)

- Пропишем логику работы бота

![6.3](images/6.3.PNG)

